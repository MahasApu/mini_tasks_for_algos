def get_digits(num):
    digits = []
    while num:
        digits.append(num % 10)
        num //= 10
    return reversed(digits)


def division_algo(dividend, divider):
    result = 0
    remainder = 0
    i = 0
    for dig in get_digits(dividend):
        dig += remainder * 10
        while dig >= i * divider:
            i += 1
        if i:
            i -= 1
            remainder = dig - i * divider
        else:
            remainder = dig
        result = result * 10 + i

    return result, remainder
# Оценка сложности алгоритма
# пусть у нас есть два числа длины n и m соотсветсвенно. Рассмотрим деление первого числа на второе (ситуация когда n>=m).
# алгоритм начинает работу с выборки первых m (или m+1) цифр делимого, так, чтобы наше "новое" подчисло было >= чем делитель.
# следовательно алгоритм пройдет по n-m+1 цифрам делимого. Также необходимо циклом while найти такое число С*m (C от 1 до 10), чтобы при умножении C на делитель
# мы получили максимально возможное число, не превышающее "новое" подчисло:
# Так, наихудшей ситуацией будет случай, когда нам каждый раз нужно заходить в цикл while и проходить 10 итерций (число вида 10*m) для поиска множителя.
# т.е. количество операций (n-m+1)*(C*m) = C*n*m -C*m*m + C*m = O(n*m) в наихудшем случае равно 10*n*m,
# тогда как при наилучшем раскладе мы сразу будем иметь подходящее число (т.е. С = 1 => 1*n*m)